---
title: "QC"
output:
  md_document:
    toc: yes
---
# Quality control and normalization

```{r Setup, include=F}
input_dataPath <- "~/Sonya_data/woodchuck/Mcgilvery_sonya_Lp648_TLH/filtered_gene_bc_matrices/marMar2.1" # path to 10X output directory (containing .mtx file)
raw_dir <- "~/Sonya_data/woodchuck/Mcgilvery_sonya_Lp648_TLH/raw_gene_bc_matrices/marMar2.1"

dataPath <- "../scClustViz_files/soupTest/wc_L9648/" # path to analysis output directory

dataSpecies <- "woodchuck" #set species
dataName <- "soupTest" # name your overall analysis
sampleName <- "L9648" # name your sample

library(Matrix)
library(scales)
library(viridis)
library(biomaRt)
library(scran) # from Bioconductor
library(DropletUtils) # from Bioconductor
library(rtracklayer)
library(SoupX)

if (Sys.info()["sysname"] == "Windows") { sys <- "D:/" } else { sys <- "~/" }
if (dataSpecies == "mouse") {
  mart <- useMart(biomart="ensembl",dataset="mmusculus_gene_ensembl")
  speciesSymbol <- "mgi_symbol"
  speciesMito <- "^mt-"
  #cycloneSpeciesMarkers <- "mouse_cycle_markers.rds" # Going to use Seurat's cell cycle annotations instead.
} else if (dataSpecies == "human") {
  mart <- useMart(biomart="ensembl",dataset="hsapiens_gene_ensembl")
  speciesSymbol <- "hgnc_symbol"
  speciesMito <- "^MT-"
  #cycloneSpeciesMarkers <- "human_cycle_markers.rds"
} else if (dataSpecies == "woodchuck"){
  gffPath <- "~/genomes/GCF_001458135.1_marMar2.1_genomic.gff"
  hepGffPath <- "~/genomes/WoodchuckHepatitisGenome.gff3"
  mitoGffPath <- "~/genomes/MarmotaHimalayanaMitochondrialGenome.gff3"
  speciesSymbol <- "marmot_symbol"
  speciesMito <- "^mt-"
  
} else if (dataSpecies == "cmv"){
  cmvPath <- "~/genomes/GSE41605_merlin_final_orfs.bed"
  mart <- useMart(biomart="ensembl",dataset="hsapiens_gene_ensembl")
  speciesSymbol <- "hgnc_symbol"
  speciesMito <- "^MT-"
  #cycloneSpeciesMarkers <- "human_cycle_markers.rds"
} else { print("Set species please!") }
dir.create(dataPath,recursive=T,showWarnings=F)

plotHistHoriz <- function(input,col="grey80",add=F) {
  tempH <- hist(input,breaks=50,plot=F)
  if (!add) {
    plot(x=NULL,y=NULL,xlim=range(tempH$counts),ylim=range(input),
         bty="n",ylab=NA,yaxt="n",xaxt="n",xlab=NA)
  }
  rect(xleft=rep(0,length(tempH$counts)),ybottom=tempH$breaks[-length(tempH$breaks)],
       xright=tempH$counts,ytop=tempH$breaks[-1],col=col)
}

rainbow2 <- function(n,a=1) {
  require(scales)
  hues = seq(15, 375, length = n + 1)
  alpha(hcl(h = hues, l = 60, c = 100)[1:n],a)
}
```

# Cell filtering

```{r load_data, include=F}
ebRaw <- Read10X(input_dataPath)
ebRaw <- ebRaw[Matrix::rowSums(ebRaw) > 0,]
ebRaw <- ebRaw[,Matrix::colSums(ebRaw) > 0]

##  Check rownames at this point.  This workflow expects MGI or HGNC gene symbols as the rownames.
##  If the data was aligned to a reference genome that used ensembl gene IDs or another annotation
##  you will have to either convert them to gene symbols, or identify which ensembl IDs correspond
##  to the mitochondrial genome for the mitoFilt step.

geneRowNames <- "ensembl_gene_id" # Set to this if rownames are ensemble gene IDs
geneRowNames <- speciesSymbol   # Set to this if rownames are official gene symbols (don't need converting).

if (geneRowNames != speciesSymbol) {
  if (dataSpecies == "woodchuck") {
    gff <- mcols(import.gff(gffPath, format="gff3"))
    gff <- gff[,c("ID","gene")]
    gff[!complete.cases(gff),"gene"] <- gff[!complete.cases(gff),"ID"]
    gff <- gff[gff$ID %in% rownames(ebRaw),]
    
    hepGff <- mcols(import.gff(hepGffPath, format="gff3"))
    hepGff <- hepGff[,c("ID","locus_tag")]
    hepGff[!complete.cases(hepGff),"locus_tag"] <- hepGff[!complete.cases(hepGff),"ID"]
    hepGff <- hepGff[hepGff$ID %in% rownames(ebRaw),]
    
    mitoGff <- mcols(import.gff(mitoGffPath, format="gff3"))
    mitoGff[!complete.cases(mitoGff$gene),"gene"] <- mitoGff[!complete.cases(mitoGff$gene),"product"]
    mitoGff[!complete.cases(mitoGff$gene),"gene"] <- mitoGff[!complete.cases(mitoGff$gene),"ID"]
    mitoGff <- mitoGff[,c("ID","gene")]
    mitoGff$gene <- sapply(mitoGff$gene, function(i){paste0("mt-",i)}, USE.NAMES=FALSE)
    mitoGff <- mitoGff[mitoGff$ID %in% rownames(ebRaw),]

    
    colnames(gff) <- c(geneRowNames, speciesSymbol)
    colnames(hepGff) <- c(geneRowNames, speciesSymbol)
    colnames(mitoGff) <- c(geneRowNames, speciesSymbol)

    e2g <- rbind(gff,hepGff,mitoGff)
  } else if (dataSpecies == "cmv"){
    e2g <- getBM(attributes=c(geneRowNames,speciesSymbol),
                 mart=mart,filters=geneRowNames,
                 values=rownames(ebRaw))
    cmvGenes <- read.table(paste0(input_dataPath,"/genes.tsv"),sep = '\t')
    colnames(cmvGenes) <- c("ensembl_gene_id", "hgnc_symbol")
    rownames(cmvGenes) <- cmvGenes$ensembl_gene_id
    
    new <- rbind(e2g,cmvGenes)
  } else {
    e2g <- getBM(attributes=c(geneRowNames,speciesSymbol),
               mart=mart,filters=geneRowNames,
               values=rownames(ebRaw))
  }
  
  e2g <- e2g[e2g[,speciesSymbol] != "",] # removing unmapped gene symbols from conversion table
  print(paste(sum(duplicated(e2g[,geneRowNames])),geneRowNames,"mapped to multiple",speciesSymbol))
  ##  Arbitrarily picking one mapping for the above duplicates, since these generally map to predicted genes anyway.
  e2g <- e2g[!duplicated(e2g[,geneRowNames]),] 
  rownames(e2g) <- e2g[,geneRowNames]
  ebRaw <- ebRaw[e2g[,geneRowNames],] # removing unmapped genes from data
  print(paste(sum(duplicated(e2g[,speciesSymbol])),speciesSymbol,"mapped to multiple",geneRowNames))
  ##  Going to collapse these by summing UMI counts between duplicated rows.
  temp_r <- ebRaw[e2g[,speciesSymbol] %in% e2g[,speciesSymbol][duplicated(e2g[,speciesSymbol])],]
  ebRaw <- ebRaw[!e2g[,speciesSymbol] %in% e2g[,speciesSymbol][duplicated(e2g[,speciesSymbol])],]
  ##  Removed duplicated rows from data, saved as separate object
  rownames(ebRaw) <- e2g[rownames(ebRaw),speciesSymbol] # renamed rows in data as gene symbols
  if (nrow(temp_r) >0){
    temp_r <- Matrix(t(sapply(e2g[,speciesSymbol][duplicated(e2g[,speciesSymbol])],function(X) {
      Matrix::colSums(temp_r[e2g[,geneRowNames][e2g[,speciesSymbol] == X],])})),sparse=T)
    ##  Collapsed by summing each duplicated gene symbol's row
    ebRaw <- rbind(ebRaw,temp_r)  # added those data back to matrix
  }
}

# Consolidate duplicated gene names (if genes are in under their MGI and HGNC symbols)
if (any(duplicated(toupper(rownames(ebRaw))))) {
  print(paste(dataName,"-",sum(duplicated(toupper(rownames(ebRaw)))),"duplicated gene names."))
  temp_r <- which(as.logical(Matrix::rowSums(
    sapply(rownames(ebRaw)[duplicated(toupper(rownames(ebRaw))),drop=FALSE],
           function(X) grepl(paste0("^",X,"$"),rownames(ebRaw),ignore.case=T)))))
  temp_r2 <- rownames(ebRaw[temp_r,,drop=FALSE])[rownames(ebRaw[temp_r,,drop=FALSE]) %in% keys(get(egDB),"SYMBOL")]
  temp_reps <- t(sapply(lapply(unique(temp_r2),function(X) 
    grep(paste0("^",X,"$"),rownames(ebRaw),ignore.case=T)),
    function(Y) Matrix::colSums(ebRaw[Y,,drop=FALSE])))
  rownames(temp_reps) <- temp_r2
  ebRaw <- ebRaw[-temp_r,]
  ebRaw <- rbind(ebRaw,temp_reps)
  ebRaw <- ebRaw[Matrix::rowSums(ebRaw) > 0,]
  ebRaw <- ebRaw[,Matrix::colSums(ebRaw) > 0]
}

rm(list=ls()[grepl("temp",ls())])
```

```{r plot_knee2, echo=F,fig.height=4.2,fig.width=8.4}
libSize <- Matrix::colSums(ebRaw)
cumCounts <- cumsum(libSize[order(libSize,decreasing=T)])
maxCount <- 10^ceiling(log10(max(libSize)))
countCols <- cut(log10(libSize[order(libSize,decreasing=T)]),
                 breaks=floor(log10(min(libSize))):ceiling(log10(max(libSize))),
                 labels=F,include.lowest=T)
layout(matrix(c(3,3,1:2),nrow=2,byrow=T),heights=c(1,3.2))
par(mar=c(3,3,1,1),mgp=2:0)
plot(seq_along(cumCounts),cumCounts/max(cumCounts),pch=19,ylim=c(0,1),
     col=viridis(max(countCols),d=-1)[countCols],
     xlab="Cell libraries (largest to smallest)",ylab="Cumulative fraction of UMIs")
plot(seq_along(cumCounts),cumCounts/max(cumCounts),pch=19,log="x",ylim=c(0,1),
     col=viridis(max(countCols),d=-1)[countCols],
     xlab="Cell libraries (largest to smallest)",ylab="Cumulative fraction of UMIs")
par(mar=c(3,1,2,1))
barplot(rep(1,max(countCols)),col=viridis(max(countCols),d=-1),
        space=0,border=NA,axes=F,xlab="UMIs per cell")
axis(side=1,at=0:max(countCols),
     labels=sapply(floor(log10(min(libSize))):ceiling(log10(max(libSize))),function(X) 10^X))
title(main="STAMPs from cells by UMIs per STAMP")
```

## Mitochondrial gene content  

Filtering cells based on the proportion of mitochondrial gene transcripts per cell.  A high proportion of mitochondrial gene  transcripts are indicative of poor quality cells, probably due to compromised cell membranes.  Removal of these cells shouldn't decrease the complexity of the overall dataName (measured by number of genes detected), while removing a source of noise.  

```{r mitoFilt, echo=F,fig.height=4.2,fig.width=8.4}
### Parameters you could edit ###
libsize_cut <- 0
drop_mitoMads <- 4 
# ^ Median absolute deviations from the median to use as threshold for mitochondrial transcript proprotion
hard_mitoCut <- 0.5
# ^ Hard threshold for mitochondrial transcript proportion

### Calculations and filtering ###
temp_geneDetectFx <- function(ebRaw) { 
  if (is.null(slotNames(ebRaw))) {
    apply(ebRaw,2,function(X) sum(X>0))
  } else if ("j" %in% slotNames(ebRaw)) {
    as.vector(table(ebRaw@j))
  } else {
    as.vector(table(rep(seq_along(diff(ebRaw@p)),diff(ebRaw@p))))
  }
}
cellStats <- data.frame(libSize=Matrix::colSums(ebRaw),
                        geneDetect=temp_geneDetectFx(ebRaw),
                        mitoPct=Matrix::colSums(ebRaw[grepl(speciesMito,rownames(ebRaw)),]) / 
                          Matrix::colSums(ebRaw))

drop_mitoCut <- median(cellStats$mitoPct) + mad(cellStats$mitoPct) * drop_mitoMads
if (drop_mitoCut > hard_mitoCut) { drop_mitoCut <- hard_mitoCut }
drop_mito <- cellStats$mitoPct > drop_mitoCut

ebRawF <- ebRaw[,!drop_mito]
cellStatsF <- cellStats[!drop_mito,]
ebRawF <- ebRawF[Matrix::rowSums(ebRawF) > 0,]
ebRawF <- ebRawF[,Matrix::colSums(ebRawF) > libsize_cut]
cellStatsF <- cellStatsF[cellStatsF$libSize > libsize_cut,]


### Plotting ###
layout(matrix(c(2,1,0,3,5,4,0,6),2),c(3.7,.5,3.7,.5),c(0.5,3.7))
par(mar=c(3,3,0,0),mgp=2:0)
plot(mitoPct~libSize,data=cellStats,log="x",
     pch=21,cex=1.2,col=alpha("black",0.2),bg=alpha("black",0.1),
     xlab="Transcripts detected per cell (log scale)",
     ylab="Transcript proportion from mitochondrial genome")
abline(h=drop_mitoCut,lwd=2,lty=2,col=alpha("red",0.5))
abline(v=libsize_cut, lwd=2, lty=2, col=alpha("blue",0.8))
mtext(paste(dataName,"damaged cells"),side=3,adj=0.98,line=-1.5,font=2,cex=1)
legend("topright",bty="n",inset=c(0,.05),
       lty=c(2,NA,NA,NA,NA),lwd=c(2,NA,NA,NA,NA),col=alpha(c("red",NA,NA,NA,NA),0.5),
       legend=c(paste(drop_mitoMads,"MADs above median"),
                paste(sum(drop_mito),"cells removed"),
                paste(ncol(ebRawF),"cells remain"),
                paste(nrow(ebRaw)-nrow(ebRawF),"genes removed"),
                paste(nrow(ebRawF),"genes remain")))
par(mar=c(0,3,0,0))
hist(log10(cellStats$libSize),freq=F,breaks=50,col="grey80",
     main=NULL,xlab=NA,ylab=NA,xaxt="n",yaxt="n")
par(mar=c(3,0,0,0))
plotHistHoriz(cellStats$mitoPct)

par(mar=c(3,3,0,0))
plot(mitoPct~geneDetect,data=cellStats,log="x",
     pch=21,cex=1.2,col=alpha("black",0.2),bg=alpha("black",0.1),
     xlab="Genes detected per cell (log scale)",
     ylab="Transcript proportion from mitochondrial genome")
abline(h=drop_mitoCut,lwd=2,lty=2,col=alpha("red",0.5))
mtext(paste(dataName,"damaged cells"),side=3,adj=0.98,line=-1.5,font=2,cex=1)
legend("topright",bty="n",inset=c(0,.05),
       lty=c(2,NA,NA,NA,NA),lwd=c(2,NA,NA,NA,NA),col=alpha(c("red",NA,NA,NA,NA),0.5),
       legend=c(paste(drop_mitoMads,"MADs above median"),
                paste(sum(drop_mito),"cells removed"),
                paste(ncol(ebRawF),"cells remain"),
                paste(nrow(ebRaw)-nrow(ebRawF),"genes removed"),
                paste(nrow(ebRawF),"genes remain")))
par(mar=c(0,3,0,0))
hist(log10(cellStats$geneDetect),freq=F,breaks=50,col="grey80",
     main=NULL,xlab=NA,ylab=NA,xaxt="n",yaxt="n")
par(mar=c(3,0,0,0))
plotHistHoriz(cellStats$mitoPct)
```

## Outlier filtering  

While it isn't possible to explicitly filter for doublets at this stage (see [doublet filtering assessment](doubletFilterTest)), it is important to manually inspect the relationship between library size and gene detection rates per cell to identify obvious outliers.  Outliers can be identified systematically using a sufficiently extreme number of median absolute deviations from the median, assuming a moderately normal distribution.  Since library sizes tend to be log-normal, we use log-transformed library size to identify outliers.  We used 4 MADs above the median of the log-transformed library size as a threshold to define outliers.

```{r doubFilt, echo=F,fig.height=4.2,fig.width=8.4,fig.show="hold"}
### Parameters you could edit ###
outToInspect <- rep(F,nrow(cellStatsF)) # None
# outToRemove <- rep(F,nrow(cellStatsF)) # None
numMADs <- 5 # Median absolute deviations from the median to consider as an outlier.
outToRemove <- rep(F,ncol(ebRawF))
  #log10(cellStatsF$libSize) > median(log10(cellStatsF$libSize)) + 
  #mad(log10(cellStats$libSize)) * numMADs
# Assuming an approximately log-normal distribution of library sizes, this removes obvious outliers. 
# (>3 MADs from the median of the log-transformed library size)

### Calculations and filtering ###
ebRawF2 <- ebRawF[,!outToRemove]
ebRawF2 <- ebRawF2[Matrix::rowSums(ebRawF2) > 0,]

### Plotting ###
layout(cbind(matrix(c(2,1,0,3),2),matrix(c(5,4,0,6),2)),widths=c(3.5,.7,3.5,.7),heights=c(.7,3.5))
par(mar=c(3,3,0,0),mgp=2:0)
plot(geneDetect~libSize,data=cellStatsF[!outToInspect,],
     xlim=range(cellStatsF$libSize),ylim=range(cellStatsF$geneDetect),
     pch=21,col=alpha("black",0.2),bg=alpha("black",0.1),cex=1.2,
     xlab="Transcripts detected per cell",ylab="Genes detected per cell")
points(geneDetect~libSize,data=cellStatsF[outToInspect,],
       pch=24,col=alpha("blue",0.2),bg=alpha("blue",0.1),cex=1.2)
points(geneDetect~libSize,data=cellStatsF[outToRemove,],
       pch=4,cex=1.2,col="red")
mtext(paste(dataName,"cell stats"),side=3,adj=0.02,line=-1.5,font=2,cex=1)
legend("bottomright",bty="n",pch=c(24,4,NA,NA),
       col=c("blue","red",NA,NA),pt.bg=alpha(c("blue",NA,NA,NA),0.3),
       legend=c(paste("Outliers to inspect:",sum(outToInspect)),
                paste("Outliers to remove:",sum(outToRemove)),
                paste(nrow(ebRawF)-nrow(ebRawF2),"genes removed"),
                paste(nrow(ebRawF2),"genes remain")))
par(mar=c(0,3,1,0))
hist(cellStatsF$libSize[!outToInspect | !outToRemove],
     freq=T,breaks=50,col="grey80",main=NULL,xlab=NA,ylab=NA,xaxt="n",yaxt="n")
if (any(outToInspect)) {
  hist(cellStatsF$libSize[outToInspect],add=T,
       freq=T,breaks=50,col=alpha("blue",.5),main=NULL,xlab=NA,ylab=NA,xaxt="n",yaxt="n")
}
if (any(outToRemove)) {
  hist(cellStatsF$libSize[outToRemove],add=T,
       freq=T,breaks=50,col=alpha("red",.5),main=NULL,xlab=NA,ylab=NA,xaxt="n",yaxt="n")
}
par(mar=c(3,0,0,1))
plotHistHoriz(cellStatsF$geneDetect[!outToInspect | !outToRemove])
if (any(outToInspect)) {
  plotHistHoriz(cellStatsF$geneDetect[outToInspect],col=alpha("blue",.5),add=T)
}
if (any(outToRemove)) {
  plotHistHoriz(cellStatsF$geneDetect[outToRemove],col=alpha("red",.5),add=T)
}

par(mar=c(3,3,0,0),mgp=2:0)
plot(geneDetect~libSize,data=cellStatsF[!outToInspect,],log="xy",
     xlim=range(cellStatsF$libSize),ylim=range(cellStatsF$geneDetect),
     pch=21,col=alpha("black",0.2),bg=alpha("black",0.1),cex=1.2,
     xlab="Transcripts detected per cell (log scale)",
     ylab="Genes detected per cell (log scale)")
points(geneDetect~libSize,data=cellStatsF[outToInspect,],
       pch=24,col=alpha("blue",0.2),bg=alpha("blue",0.1),cex=1.2)
points(geneDetect~libSize,data=cellStatsF[outToRemove,],
       pch=4,cex=1.2,col="red")
mtext(paste(dataName,"cell stats"),side=3,adj=0.02,line=-1.5,font=2,cex=1)
legend("topleft",bty="n",inset=c(0,.05),pch=c(24,4,NA,NA),
       col=c("blue","red",NA,NA),pt.bg=alpha(c("blue",NA,NA,NA),0.3),
       legend=c(paste("Outliers to inspect:",sum(outToInspect)),
                paste("Outliers to remove:",sum(outToRemove)),
                paste(nrow(ebRawF)-nrow(ebRawF2),"genes removed"),
                paste(nrow(ebRawF2),"genes remain")))
par(mar=c(0,3,1,0))
hist(log10(cellStatsF$libSize[!outToInspect | !outToRemove]),
     freq=T,breaks=50,col="grey80",main=NULL,xlab=NA,ylab=NA,xaxt="n",yaxt="n")
if (any(outToInspect)) {
  hist(log10(cellStatsF$libSize[outToInspect]),add=T,
       freq=T,breaks=50,col=alpha("blue",.5),main=NULL,xlab=NA,ylab=NA,xaxt="n",yaxt="n")
}
if (any(outToRemove)) {
  hist(log10(cellStatsF$libSize[outToRemove]),add=T,
       freq=T,breaks=50,col=alpha("red",.5),main=NULL,xlab=NA,ylab=NA,xaxt="n",yaxt="n")
}
par(mar=c(3,0,0,1))
plotHistHoriz(log10(cellStatsF$geneDetect[!outToInspect | !outToRemove]))
if (any(outToInspect)) {
  plotHistHoriz(log10(cellStatsF$geneDetect[outToInspect]),col=alpha("blue",.5),add=T)
}
if (any(outToRemove)) {
  plotHistHoriz(log10(cellStatsF$geneDetect[outToRemove]),col=alpha("red",.5),add=T)
}
```
While filtering out abnormally large libraries won't capture all doublets, these libraries are likely the result of capturing multiple cells in a droplet.  Removing these cells did not significantly affect the complexity of the dataName (minimal genes unique to these cells).


## Outlier inspection 

```{r what_are_those_cells, echo=FALSE,fig.height=4.2,fig.width=8.4}
if (any(outToInspect)) {
  ### Parameters you could edit ###
  topNum <- 3 # Number of highly expressed genes in outlier population to highlight
  removeOutlierPopulation <- T # Do you want to remove this outlier population from the analysis?
  
  ### Calculations ###
  gsOut <- data.frame(DR=apply(ebRawF2[,outToInspect[!outToRemove]],1,function(X) sum(X > 0)/length(X)),
                      MDTC=apply(ebRawF2[,outToInspect[!outToRemove]],1,function(X) mean(X[X>0])),
                      MTC=Matrix::rowMeans(ebRawF2[,outToInspect[!outToRemove]]))
  rownames(gsOut) <- rownames(ebRawF2)
  gsIn <- data.frame(DR=apply(ebRawF2[,!outToInspect[!outToRemove]],1,function(X) sum(X > 0)/length(X)),
                     MDTC=apply(ebRawF2[,!outToInspect[!outToRemove]],1,function(X) mean(X[X>0])),
                     MTC=Matrix::rowMeans(ebRawF2[,!outToInspect[!outToRemove]]))
  rownames(gsIn) <- rownames(ebRawF2)
  if (removeOutlierPopulation) {
    ebRawF3 <- ebRawF2[,!outToInspect[!outToRemove]]
    ebRawF3 <- ebRawF3[Matrix::rowSums(ebRawF3) > 0,]
  } else { ebRawF3 <- ebRawF2 }
  topHits <- 1:nrow(gsOut) %in% head(order(gsOut$MTC,decreasing=T),topNum)
  
  ### Plotting ###
  par(mfrow=c(1,2),mar=c(3,3,2,1),mgp=2:0)
  plot(log10(MDTC)~DR,data=gsOut,
       pch=21,cex=1.2,xlab="Proportion of cells detecting gene",
       ylab=expression(Log[10]~"Mean non-zero gene count"),
       col=alpha(c("black","red"),0.3)[topHits+1],
       bg=alpha(c("black","red"),0.1)[topHits+1],
       main=paste(dataName,"outlier cells"))
  text(log10(MDTC)~DR,data=gsOut[topHits,],
       labels=rownames(gsOut)[topHits],pos=2,col="red",cex=1.2)
  if (removeOutlierPopulation) {
    legend("topleft",inset=c(-.06,-.02),bty="n",cex=0.9,
           legend=c(paste(ncol(ebRawF2)-ncol(ebRawF3),"cells removed"),
                paste(ncol(ebRawF3),"cells remain"),
                paste(nrow(ebRawF2)-nrow(ebRawF3),"genes removed"),
                paste(nrow(ebRawF3),"genes remain")))
  } else {
    legend("topleft",inset=c(-.06,-.02),bty="n",cex=0.9,
           legend=c(paste(sum(outToInspect[!outToRemove]),"outlier cells"),
                paste(sum(!outToInspect[!outToRemove]),"cells in main population"),
                paste(nrow(ebRawF3)-sum(Matrix::rowSums(ebRawF3[,!outToInspect[!outToRemove]]) > 0),
                      "genes unique to outliers"),
                paste(sum(Matrix::rowSums(ebRawF2[,!outToInspect[!outToRemove]]) > 0),
                      "genes in main population")))
  }

  plot(log10(MDTC)~DR,data=gsIn,
       pch=21,cex=1.2,xlab="Proportion of cells detecting gene",
       ylab=expression(Log[10]~"Mean non-zero gene count"),
       col=alpha(c("black","red"),0.3)[topHits+1],
       bg=alpha(c("black","red"),0.1)[topHits+1],
       main=paste(dataName,"main cell population"))
  text(log10(MDTC)~DR,data=gsIn[topHits,],
       labels=rownames(gsIn)[topHits],pos=2,col="red",cex=1.2)
} else { ebRawF3 <- ebRawF2 }
```


```{r cleanup1, include=F}
rm(list=ls()[!ls() %in% c("ebRawF3","dataName","dataPath","plotHistHoriz","rainbow2",
                          "egDB","dataSpecies","cycloneSpeciesMarkers","geneLengthPath","raw_dir","sampleName")])
gc()
```
# SoupX Identification of Non expressed genes
```{r soupxNEG, include=F}

rawData <- Read10X(raw_dir) # load raw, unfiltered matrix output from cell ranger
rawData <- rawData[rownames(ebRawF3),,drop=FALSE] # remove filtered genes from raw matrix

sc <- SoupChannel(rawData,ebRawF3,sampleName)

if (!file.exists(paste0(dataPath, "soup.RData"))){
  scl <- SoupChannelList(list(sc))
} else {
  load(paste0(dataPath,"soup.RData"))
  sclist <- scl$channels #extract existing soup channels
  sclist[[sampleName]] <- sc # add new soup channel
  scl <- SoupChannelList(sclist) # update new soup channel list
}

# add sc to soupChannelList
scl <- inferNonExpressedGenes(scl)

print("Algorithmically determined non-expressed genes are:")

tstGenes = rownames(scl$channels[[sampleName]]$nonExpressedGenes)[seq(20)]
print(tstGenes)
```
# SoupX Step 2
```{r}
# Set the non-expressed genes you actually want to use here
tstGenes <- tstGenes

scl <- calculateContaminationFraction(scl, sampleName, list(tst = tstGenes))
scl <- interpolateCellContamination(scl, sampleName, useGlobal = TRUE)
scl <- strainCells(scl)

# Save update scl to file
save(scl, file=paste0(dataPath,"soup.RData"))
rm(list=ls())
gc()
```